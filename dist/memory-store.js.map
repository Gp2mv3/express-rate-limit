{"version":3,"file":"memory-store.js","sourceRoot":"","sources":["../source/memory-store.ts"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B,gCAAgC;AAIhC;;;;;;;;GAQG;AACH,MAAM,sBAAsB,GAAG,CAAC,QAAgB,EAAQ,EAAE;IACzD,MAAM,SAAS,GAAG,IAAI,IAAI,EAAE,CAAA;IAC5B,SAAS,CAAC,eAAe,CAAC,SAAS,CAAC,eAAe,EAAE,GAAG,QAAQ,CAAC,CAAA;IACjE,OAAO,SAAS,CAAA;AACjB,CAAC,CAAA;AAED;;;;;GAKG;AACH,MAAM,CAAC,OAAO,OAAO,WAAW;IAgB/B;;;;OAIG;IACH,YAAY,QAAgB;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACxB,IAAI,CAAC,IAAI,GAAG,EAAE,CAAA;QACd,IAAI,CAAC,SAAS,GAAG,sBAAsB,CAAC,QAAQ,CAAC,CAAA;QAEjD,kDAAkD;QAClD,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE;YACjC,IAAI,CAAC,QAAQ,EAAE,CAAA;QAChB,CAAC,EAAE,QAAQ,CAAC,CAAA;QACZ,IAAI,QAAQ,CAAC,KAAK,EAAE;YACnB,QAAQ,CAAC,KAAK,EAAE,CAAA;SAChB;IACF,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,CAAC,GAAW,EAAE,QAA2B;;QACjD,MAAM,OAAO,GAAG,CAAC,MAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,mCAAI,CAAC,CAAC,GAAG,CAAC,CAAA;QACzC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAA;QAExB,QAAQ,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;IAC7C,CAAC;IAED;;;;;;OAMG;IACH,SAAS,CAAC,GAAW;QACpB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QAC9B,IAAI,OAAO,EAAE;YACZ,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,GAAG,CAAC,CAAA;SAC5B;IACF,CAAC;IAED;;;;;;OAMG;IACH,QAAQ,CAAC,GAAW;QACnB,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;IACtB,CAAC;IAED;;;;OAIG;IACH,QAAQ;QACP,IAAI,CAAC,IAAI,GAAG,EAAE,CAAA;QACd,IAAI,CAAC,SAAS,GAAG,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;IACvD,CAAC;CACD","sourcesContent":["// /source/memory-store.ts\n// A memory store for hit counts\n\nimport { Store, IncrementCallback } from '.'\n\n/**\n * Calculates the time when all hit counters will be reset.\n *\n * @param windowMs {number} - The duration of a window (in milliseconds)\n *\n * @returns {Date}\n *\n * @private\n */\nconst calculateNextResetTime = (windowMs: number): Date => {\n\tconst resetTime = new Date()\n\tresetTime.setMilliseconds(resetTime.getMilliseconds() + windowMs)\n\treturn resetTime\n}\n\n/**\n * A {@link Store} that stores the hit count for each client in\n * memory.\n *\n * @public\n */\nexport default class MemoryStore implements Store {\n\t/**\n\t * The duration of time before which all hit counts are reset (in milliseconds).\n\t */\n\twindowMs: number\n\n\t/**\n\t * The map that stores the number of hits for each client in memory.\n\t */\n\thits: { [key: string]: number | undefined }\n\n\t/**\n\t * The time at which all hit counts will be reset.\n\t */\n\tresetTime: Date\n\n\t/**\n\t * @constructor for {@link MemoryStore}\n\t *\n\t * @param windowMs {number} - The duration of a window (in milliseconds)\n\t */\n\tconstructor(windowMs: number) {\n\t\tthis.windowMs = windowMs\n\t\tthis.hits = {}\n\t\tthis.resetTime = calculateNextResetTime(windowMs)\n\n\t\t// Reset hit counts for ALL clients every windowMs\n\t\tconst interval = setInterval(() => {\n\t\t\tthis.resetAll()\n\t\t}, windowMs)\n\t\tif (interval.unref) {\n\t\t\tinterval.unref()\n\t\t}\n\t}\n\n\t/**\n\t * Method to increment a client's hit counter.\n\t *\n\t * @param key {string} - The identifier for a client\n\t * @param callback {IncrementCallback} - The callback to call once the counter is incremented\n\t *\n\t * @public\n\t */\n\tincrement(key: string, callback: IncrementCallback) {\n\t\tconst current = (this.hits[key] ?? 0) + 1\n\t\tthis.hits[key] = current\n\n\t\tcallback(undefined, current, this.resetTime)\n\t}\n\n\t/**\n\t * Method to decrement a client's hit counter.\n\t *\n\t * @param key {string} - The identifier for a client\n\t *\n\t * @public\n\t */\n\tdecrement(key: string) {\n\t\tconst current = this.hits[key]\n\t\tif (current) {\n\t\t\tthis.hits[key] = current - 1\n\t\t}\n\t}\n\n\t/**\n\t * Method to reset a client's hit counter.\n\t *\n\t * @param key {string} - The identifier for a client\n\t *\n\t * @public\n\t */\n\tresetKey(key: string) {\n\t\tdelete this.hits[key]\n\t}\n\n\t/**\n\t * Method to reset everyone's hit counter.\n\t *\n\t * @public\n\t */\n\tresetAll() {\n\t\tthis.hits = {}\n\t\tthis.resetTime = calculateNextResetTime(this.windowMs)\n\t}\n}\n"]}